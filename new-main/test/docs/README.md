- git add . - добавляет изменения в файлах
- git status - дает понимание, какие файлы были изменены, добавлены или удалены. Но не сделан коммит.
- git commit -m "Описание изменений" - фиксирует изменения в репозитории.
- git log - выводит всю историю коммитов. Кто, что, когда изменил.
- git show - дает информацию о конкретном коммите. Дата, автор, что изменилась.
- git diff - разница между текущими изменениями и последним коммитом. Показывает, что именно изменилось в файлах.
- git restore - отменяет все изменения в файлах, возвращает к состоянию последнего коммита.
- git rm - удаляет файлы из Git, а так же из рабочей папки в случае необходимости.
- git reset - отменяет все коммиты и возвращает проект к более раннему этапу.
- git branch - показывает список веток.
- git branch "имя ветки" - создаем новую ветку.
- git branch -d "имя ветки" - удаляем ветку с названием.
- git pull - переносит актуальные изменения с гита на наш репозиторий. Желательно находится на главной ветке в момент выполнения.
- git push - отправляет изменения в удаленный репозиторий. Работает только после коммита.
- git help -а - показывает все доступные команды Git.
- git clone url - скопировать/склонировать удалённый репозиторий

### Понятие репозитория. Структура проекта. ###

# Репозиторий - хранилище кода проекта, включающее:
    1. Все файлыы и папки проекта.
    2. Историю изменений (commit).
    3. Информацию о тегах и настройках.
Виды репозиториев: 
    1. Локальные репозитории. Хранится на компьюетере разработчика (папка .git)
    2. Удаленные репозитории. Размещен на сервере (github либо gitlab)

# Базовая структура проекта Git. #
    О всех проектах


название проекта/  # Корневая папка проекта

.git/    # Скрытая папка с данными Git (история, настройки)

src/    # Исходный код (например, main.py, index. js)
docs/   # Документация (README.md, API-описание)
tests/  # Тесты (unit-тесты, интеграционные тесты)
config/ # Файлы конфигурации (настройки сервера, БД)
assets/ # Ресурсы (изображения, шрифты)

gitignore # Файл, указывающий, какие файлы Git должен игнорировать

# Жизненый цикл файлов Git #
Файлы проходят несколько стадий 
    1. Не отслеживаемая - git о них не знает.
    2. Измененный - это файлы которые были в репозитории и подверглись изменениям.
    3. Индексированные - файлы которые подготовленные к commit. (Была выполнена команда git add)
    4. Зафиксированные - изменения сохранены в репозитори. (git commit)

# Важные правила #
Пенис
    1. Каждые изменения должны быть логически завершенным.
    2. gitignore обязателен.
    3. README это лицо проекта, он должен содержать описание, установку и использование, но в нашем случае он будет содержать конспект.

### Виды целей и уровней интеграции програмных модулей. ###
Програмные модули
    Интеграция програмных модулей - процесс обьединения отдельных компонентов ПО в единую систему, обеспечивающую их совместное функционирование.

Цель интеграции: 
    1. Обеспечение взаимодействия модулей.
    2. Повышение надежности и производительности системы. 
    3. Упрощение разработки и сопровождение ПО.
    4. Минимизация дублирования функционала.

# Виды интеграции програмных модулей. #
Спообы взаимодействия
    1. По способу взаимодействия
        1. Горизонтальная интеграция (объединение модулей одного уровня). Взаимодействие между сервисами в микро архитектуре
        2. Вертикальная интеграция - объединение модулей разных уровней. (Например: Клиент - серверное взаимодействие.)
    2. По степени связанности
        1. Слабая связанность, где модули взаимодействую через стандартный интерфейс (API и сообщения), что упрощает замену компонентов. Примеры: READAPE и Микросервир.
        2. Сильная связанность, модули сильно зависят друг от друга изменение одного требуют модификации других. Пример: Монолитная архитектура.
    3. По времени выполнения
        1. Статическая интеграция, компоненты связываются на этапе компиляции.
        2. Динамическая интеграция, компоненты связываются во время выполнения. Например: плагины которые загружаются в Runtine.
 # Уровни интеграции программных модулей. #

### Уровень данных ###
фы
        Интеграция через общие базы данных, файлы или очереди сообщений.
        Примеры:
            - SQL базы (MySQL, PostgreSQL).
            - Брокеры сообщений (RabbitMQ, Kafka).
### Уровень API (сервисный уровень) ###
q
    Модули взаимодействуют через API (REST, GraphQL, gRPC)/
    Примеры: 
            - Веб сервисы (Spring Boot, Flask).
            - Микросервисная архитектура.
### Уровень пользовательского интерфейса (UI) ###
1
    Интеграция через единый интерфейс (веб, мобильные приложения).
    Примеры:
            - Single Page Application (React, Angular).
            - Desktop-приложения (Electron, Qt).

### Уровень бизнес-логики ###
1
    Интеграция на уровне общих бизнес правил и процессов.
    Примеры:
            - ESP системы (SAP, 1C).
            - Workflow-движки (Camunda, Airflow).


# Инструментальные средства интеграции

### Средства сборки и управления зависимости
1
    -npm, yarn (JavaScript).
    -pip (Python)
### CI/CD - инструменты
1   
    -GitLab CI, GitHub Actions - автоматизация сборки и тестирования.
    -Docker, Kubernetes - контейнеризация и оркестрация.
# Middleware и брокеры сообщений
1
    - RabbitMQ, Apache Kafka - асихнронная интеграция.
    - Redis - кэширование и Pub/Sub.

### Автоматизация Бизнес процессов
Это использование технологий для выполнения повторяющихся задач, минимизации ручного труда и повышения эффективности работы организатора.
    Цель автоматизации:
        1. Ускорение выполнения операций.
        2. Снижение оибок из за человеческого фактора.
        3. Оптимизация затрат.
        4. Повышение прозрачности и управляемости процессов.
        5. Масштабируемость 
Виды бизнес-процессов по уровню сложности:
    1. Простые процессы - последовательные задачи без ветвлений. 
    2. Сложные процессы - включают в себя условия, циклы, параллельные потоки. Например при согласовании договора.
Виды бизнес-процессов по функциональным областям: 
    1. Область управления документооборотом. Пример: любой электронный архив.
    2. Финансы и бухгалетерия (автоматизация расчетов и отчетность).
    3. Логистика и склад (учет товаров, маршрутизация доставок)
    4. HR-процессы. Рекрутерский onboarding.
    5. Техподдержка
Уровни автоматизации:
    1. Базовый. Автоматизация простых задач, таких как рассылка E-Mail или SMS, генерация отчетов, обработка данных.
    2. Средний. Использование BPM-систем. Настройка маршрутов, согласование.
    3. Высокий. Роботизированная автоматизация процессов, искусственный интелект.

# Конфигурация prettierrc
{
    "ключ": "значение"
//максимавльное количество символов в одной строке до переноса
    "printWidth": 80, 
//ширина оступа (кол-во пробелов)
    "tabWidth": 2, 
//ставить ли ; в конце выражений JavaScripts (true/false)
    "semi": true,
//использовать одинарные или двойные ковычки
    "singleQuote": false
//правила постановки завершающей запятой (none, all, es5(везде где позволяет синтаксис))
    "traillingComma": "all"
//оставлять ли пустое пространство в круглых или квадратных скобках
    "bracketSpacing": true
//всегда ли заключать аргументы в стрелочных функциях в круглые скобки (always, avoid)
    "arrowParens": "always"
}



Источник данных – объект или система, откуда поступают данные для обработки.
Приемник данных – объект или система, куда передаются обработанные данные.
    Примеры источников данных: 
        1. Базы данных. Как SQL так и NOSQL
        2. Файлы. 
        3. API
        4. Потоки данных
    Примеры приемников: 
        1. База данных.
        2. Отчёты и визуализации.
        3. Внешние системы.
        4. Облачные хранилища.
    Критерии выбора источников и приемников данных:
При выборе учитывают:
    1. Формат данных. Структурированный, полу структурированный и не структурированный.
    2. Объем данных. Большие объемы данных требуют распределённых систем.
    3. Частоту обновления. Бывает Realtime и пакетная обработка.
    4. Безопасность и доступ по ролям.
    5. Стоимость. 
# Сопоставление объектов данных 
Сопоставление объектов данных – это процесс преобразования данных между источником и приёмником для совместимости.
Этапы сопоставления:
1.	Анализ структуры данных
2.	Преобразование типов;
3.	Маппинг полей (сопоставление названий столбцов);
4.	Обработка отсутствующих данных;
5.	Валидация (проверка на корректность).
Проблемы и решения:
1.	Несовпадение форматов – нужно использовать унифицированные форматы (Json);
2.	Потеря данных – необходимо использовать логированние и мониторинг (grafana);
3.	Проблема с производительностью – оптимизировать запросы и реализовать клиширование (быстрее обратиться к данным);
### Транспортные протоколы
Транспортные протоколы определяют правила передачи данных между системами.
Основные транспортные протоколы:
1.	HTTP/HTTPS
	HTTP (HyperText, Transfer Protocol) – протокол для передачи данных в веб-среде (незащищённый)
	HTTPS (HTTP Secure) – защищенная версия с шифрованием (SSL/TLS)
Методы: GET, POST, PUI, DELETE.
Использование: REST API, веб-приложения.
2.	WebSocket:
Двухсторонний протокол для обмена сообщениями в реальном времени.
Преимущества: низкие задержки, постоянное соединение.
Использование: чаты, онлайн-игры, биржевые кодировки.
3.	TPC/IP и UDP:
TPS (Transmission Control Protocol) – надёжная передача с подтверждением (гарантирует доставку).
Используется в HTTP, FTS, SMTP
UDP (User Datagram Protocol) – быстрая передача без гарантии доставки.
Используется в VoIP, стриминге, DNS.
4.	MQTT (Message Queuing Telemetry Transport)
Легковесный протокол для IoT и устройств с ограниченными ресурсами.
Работает по модели издатель-подписчик (Pub/Sub)
5.	AMQP (Advanced Message Queuing Protocol)
Протокол для асихронного обмена сообщениями между системами.
Поддержка очередей (RabbitMQ, Apache Kafka).
6.	gRPC (Google Remote Procedure Call)
Высокопроизводительный RPC-протокол на основе HTTP/2.
Использует бинарный формат (Protocol Buffers).

### Стандарты формирования сообщений
Форматы сообщений:
1.	Текстовые:
•	JSON – легковесный и легкочитаемый; структура: “ключ” – “значение”; используется в restAPI
•	XML – структурированный, с поддержкой схем; используется в SOAP и конфигурационных файлах
•	YAML – упрощенный синтаксис, удобен для конфигурации; используется в докере и кибернетис
2.	Бинарные

Выбор протокола и формата 
1.	для webAPI (HTTPS и JSON)
2.	стриминга, чатов, соцсетей (websocet + message par)
3.	для тестирования API (postman и свагер)

